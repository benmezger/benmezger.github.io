<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>blog on Ben Mezger</title><link>https://benmezger.github.io/categories/blog/</link><description>Recent content in blog on Ben Mezger</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 May 2020 02:39:00 -0300</lastBuildDate><atom:link href="https://benmezger.github.io/categories/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Attaching Jira issues to commit</title><link>https://benmezger.github.io/posts/attaching-jira-issues-to-commits/</link><pubDate>Sun, 24 May 2020 02:39:00 -0300</pubDate><guid>https://benmezger.github.io/posts/attaching-jira-issues-to-commits/</guid><description>TLDR ↕ Dynamically attach Jira attributes to commit body using git-hook. Check the project’s README. The place I work at requires Jira story ID and task ID attached to the commit body. Initially, I was attaching the ID to the commit body manually, by checking either my previous commit or opening up the Jira board, however, after working some hours I was easily forgetting to attach the IDs to the commit and getting annoying having to either reword them and perhaps having to lookup Jira again.</description></item><item><title>Patching requests HTTP hooks with custom arguments</title><link>https://benmezger.github.io/posts/http-hooks-with-custom-arguments/</link><pubDate>Thu, 07 May 2020 18:59:00 -0300</pubDate><guid>https://benmezger.github.io/posts/http-hooks-with-custom-arguments/</guid><description>I am working on a project where we have lots of functions integrated with external APIs. Functions where HTTP requests get dispatched, we log the current caller’s name, headers, and data (if any) in case we need to debug anything. For example:
import logging import requests LOGGER = logging.getLogger(&amp;#34;external&amp;#34;) def create_external_services(): ... LOGGER.info(f&amp;#34;[func] | Request {data}&amp;#34;) response = requests.post(&amp;#34;..&amp;#34;) LOGGER.info(f&amp;#34;[func] | Response {response.status_code} {response.text}&amp;#34;) ... def delete_external_services(): LOGGER.info(f&amp;#34;[func] | Request {data}&amp;#34;) response = requests.</description></item><item><title>Understanding key concepts before writing a Kernel</title><link>https://benmezger.github.io/posts/writting-a-kernel-part-1/</link><pubDate>Sun, 03 May 2020 12:42:00 -0300</pubDate><guid>https://benmezger.github.io/posts/writting-a-kernel-part-1/</guid><description>In this series of posts, I intend to document my re-go on writing a small, portable kernel for the RISC-V architecture. I developed a micro-kernel for the RISC-V ISA in my bachelor thesis, however, due to the time it takes on developing a kernel, and the time I had on writing a bachelor&amp;rsquo;s thesis, I choose on writing the kernel for the Sifive&amp;rsquo;s HiFive1 Rev B development board due to their well written bare metal compatibility Library for the board, low cost and most importantly, RISC-V.</description></item><item><title>Hello, org-mode and hugo</title><link>https://benmezger.github.io/posts/hello-orgmode/</link><pubDate>Thu, 23 Apr 2020 00:00:00 -0300</pubDate><guid>https://benmezger.github.io/posts/hello-orgmode/</guid><description>Hello, world! This is my first post here. This blog is created using Hugo and Emacs org-mode. I am still busy migrating my posts from Asciidoc to org-mode, so this should take a bit of time.</description></item><item><title>Finding exposed .git repositories</title><link>https://benmezger.github.io/posts/finding-exposed-git-repositories/</link><pubDate>Mon, 30 Oct 2017 21:59:00 -0200</pubDate><guid>https://benmezger.github.io/posts/finding-exposed-git-repositories/</guid><description>Developers use git to version control their source code. We all do, in fact, this blog is currently versioned by git. However, we not only use git to version control, but also to deploy applications. Usually we push new code to a remote server, where the server takes care of testing the code and then deploying the application. There are different ways of deploying an application, but this is one of them.</description></item><item><title>Notes on Linux's printk</title><link>https://benmezger.github.io/posts/notes-on-linux-printk/</link><pubDate>Thu, 09 Mar 2017 22:26:00 -0300</pubDate><guid>https://benmezger.github.io/posts/notes-on-linux-printk/</guid><description>Some of the content might be incorrect, since I am still trying to understand it thoroughly.
So I started studying the Linux Kernel more in depth, so I decided it would be nice for me to document my findings, so I can read it from time to time. I will be daily updating this post, as I am studying it everyday.
Keep in mind that I am using the x86 architecture.</description></item></channel></rss>