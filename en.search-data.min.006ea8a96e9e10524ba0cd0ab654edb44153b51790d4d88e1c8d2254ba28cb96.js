'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/attaching-jira-issues-to-commits/','title':"Attaching Jira issues to commit",'content':"  TLDR ↕  Dynamically attach Jira attributes to commit body using git-hook. Check the project’s README.    The place I work at requires Jira story ID and task ID attached to the commit body. Initially, I was attaching the ID to the commit body manually, by checking either my previous commit or opening up the Jira board, however, after working some hours I was easily forgetting to attach the IDs to the commit and getting annoying having to either reword them and perhaps having to lookup Jira again.\nThis was tedious and frustrating, so I wrote a Git hook using pre-commit to handle and install the hook. Our workflow requires the task ID to be attached to the branch same, like so: SKYR-123_branch-description, so Jira is capable of logging commits related to task branches1. This makes it easy for the hook to know which task are you working on before writing to the commit body. As it checks whether you are in a task branch or any other branch. The Jira ID branch is configurable by specifying a regex for the Jira ID, like so: SKYR-\\d+.\nGit provides a pre-commit-msg hook, which prepares the default commit message before prompting the user for the commit description/body. To allow extensibility, the hook handles custom Git template with Jinja, so each project may have a custom commit template.\nFor example, the following template will write the task ID, story ID (if any) and task description.\nTask description: {{ summary }} Jira task ID: {{ key }} {% if parent__key %}Jira story ID: {{ parent__key }}{% endif %} The fields are related to Jira’s REST fields. Inner fields such as parent.key should replace the dot (.) with a double underscore (__).\nI named the project GJira , as of Git-Jira.\n  https://www.atlassian.com/blog/bitbucket/integration-tips-jira-software-bitbucket-server \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':1,'href':'/posts/','title':"Posts",'content':""});index.add({'id':2,'href':'/posts/http-hooks-with-custom-arguments/','title':"Patching requests HTTP hooks with custom arguments",'content':"I am working on a project where we have lots of functions integrated with external APIs. Functions where HTTP requests get dispatched, we log the current caller’s name, headers, and data (if any) in case we need to debug anything. For example:\nimport logging import requests LOGGER = logging.getLogger(\u0026#34;external\u0026#34;) def create_external_services(): ... LOGGER.info(f\u0026#34;[func] | Request {data}\u0026#34;) response = requests.post(\u0026#34;..\u0026#34;) LOGGER.info(f\u0026#34;[func] | Response {response.status_code} {response.text}\u0026#34;) ... def delete_external_services(): LOGGER.info(f\u0026#34;[func] | Request {data}\u0026#34;) response = requests.delete(\u0026#34;..\u0026#34;) LOGGER.info(f\u0026#34;[func] | Response {response.status_code} {response.text}\u0026#34;) So far so good, but it gets ugly when you have a bunch of functions logging HTTP one or multiple requests and responses.\nPython’s requests has a hook system that allows us to manipulate portions of the request process or signal event handling. However, the hook is unable to receive a custom argument. requests requires hooks to have the current argument definition of: def hook(response, *args, **kwargs), however, you are unable to pass custom kwargs to the hook as requests raises a TypeError if any kwarg is not recognized.\nThe way I solved this issue was by first creating a hook patch decorator.\nfrom typing import Callable import functools import logging def patch_http( logger: logging.Logger = None, level: int = logging.INFO, log_hook: Callable = log_hook, ) -\u0026gt; Callable: if logger is None: logger = logging.getLogger(\u0026#34;http.client\u0026#34;) def decorate_http(func): @functools.wraps(func) def log_wrapper(*args, **kwargs): # fake func and logger attribute to log_hook log_hook.func = func log_hook.logger = logger log_hook.level = level return func(*args, **kwargs) return log_wrapper return decorate_http This decorator decorates functions in which requests is used. It allows us to use a custom logger, log level, and log_hook function if required. log_wrapper creates 3 dummy attributes: func which holds the address of the caller, the logger, and the log level. The log_hook requires some hacking, as we might want to use it without the need of a decorated function.\ndef log_hook(req, *args, **kwargs): if not hasattr(log_hook, \u0026#34;func\u0026#34;): log_hook.func = None if not hasattr(log_hook, \u0026#34;logger\u0026#34;): setattr(log_hook, \u0026#34;logger\u0026#34;, logging.getLogger(\u0026#34;http.client\u0026#34;)) if not hasattr(log_hook, \u0026#34;level\u0026#34;): setattr(log_hook, \u0026#34;level\u0026#34;, logging.INFO) log_hook.logger.log( log_hook.level, \u0026#34;[{}] | Request | Payload: {}\u0026#34;.format( log_hook.func.__name__ if callable(log_hook.func) else \u0026#34;\u0026#34;, req.request.data if hasattr(req.request, \u0026#34;data\u0026#34;) else {}, ), ) log_hook.logger.log( log_hook.level, \u0026#34;[{}] | Response status {} | Response {}\u0026#34;.format( log_hook.func.__name__ if callable(log_hook.func) else \u0026#34;\u0026#34;, req.status_code, req.content, ), ) return req The first lines are what allows the use of the hook regardless of the decorator, with the downside of not having a function caller named. The actual call to logging is done by using the attribute previously created by our patch_http decorator, however, if no decorator is used, it defaults to a predefined http.client logger. Now the actual change to our code:\nimport logging import requests LOGGER = logging.getLogger(\u0026#34;external\u0026#34;) @patch_http(logger=LOGGER) def create_external_services(): response = requests.post(\u0026#34;..\u0026#34;, hooks={\u0026#34;response\u0026#34;: log_hook}) @patch_http(logger=LOGGER) def delete_external_services(): response = requests.post(\u0026#34;..\u0026#34;, hooks={\u0026#34;response\u0026#34;: log_hook}) I am still not entirely convinced if using a decorator for patching the hook is the cleanest way, however, it allows us to modify the logging messages for all requests in one place without having to duplicate code or easily add custom logic to all requests.\nFor example, say we want to log only if a 404 HTTP status code gets returned in create_external_services. We could modify our decorator to create an expected_statuses and check the response status code in log_hook before logging.\nfrom typing import Callable, Tuple import functools import logging def patch_http( logger: logging.Logger = None, level: int = logging.INFO, log_hook: Callable = log_hook, expected_statuses: Tuple[int] = (200, 201) ) -\u0026gt; Callable: if logger is None: logger = logging.getLogger(\u0026#34;http.client\u0026#34;) def decorate_http(func): @functools.wraps(func) def log_wrapper(*args, **kwargs): log_hook.expected_statuses = expected_statuses log_hook.func = func log_hook.logger = logger log_hook.level = level return func(*args, **kwargs) return log_wrapper return decorate_http def log_hook(req, *args, **kwargs): ... if not hasattr(log_hook, \u0026#34;expected_statuses\u0026#34;): setattr(log_hook, \u0026#34;expected_statuses\u0026#34;, (200,)) if req.status_code in log_hook.expected_statuses: log_hook.logger.log( log_hook.level, \u0026#34;[{}] | Request | Payload: {}\u0026#34;.format( log_hook.func.__name__ if callable(log_hook.func) else \u0026#34;\u0026#34;, req.request.data if hasattr(req.request, \u0026#34;data\u0026#34;) else {}, ), ) .... return req "});index.add({'id':3,'href':'/posts/writting-a-kernel-part-1/','title':"Understanding key concepts before writing a Kernel",'content':"In this series of posts, I intend to document my re-go on writing a small, portable kernel for the RISC-V architecture. I developed a micro-kernel for the RISC-V ISA in my bachelor thesis, however, due to the time it takes on developing a kernel, and the time I had on writing a bachelor\u0026rsquo;s thesis, I choose on writing the kernel for the Sifive\u0026rsquo;s HiFive1 Rev B development board due to their well written bare metal compatibility Library for the board, low cost and most importantly, RISC-V.\nBy using Sifive\u0026rsquo;s API, it took out the overhead of having to deal with the configurations of the clock, interrupt, CPU, and generally required hardware for the kernel to run. Long story short, I submitted my thesis, got approved, and now I am willing to rewrite the code all over. During the development of my thesis, there were components I needed to write and have a better understanding, so I was not able to pay as much attention as I wanted to the project design, structural decisions, and general kernel/architectural decisions. One of the decisions I made during the development phase was not to document my ideas, questions, and answers I had. This post attempts to fix this problem, by documenting on how to write a Kernel for the RISC-V architecture.\nBefore we start, let\u0026rsquo;s remember some basic computer concepts and try to assemble them together so we can better understand how each component fits within a kernel.\nA modern computer A modern computer consists of at least one central processing unit, main memory, some data storage, and another type of input and output devices. Computer architecture is the specification on which describes how software and hardware may interact with each other. Computer processors provide an abstract model interface known as the instruction set, which serves as an interface between the hardware and software.\nThe need for a kernel Application developers need to communicate with these types of hardware, and by having to learn each computer specification is difficult and time-consuming. The kernel is the middle section of the abstraction between hardware and user software (Figure 1). It manages computer resources to allow application programmers to communicate with them.\nBy having a simpler model of the computer, application programmers can write less error-prone software by leaving the hardware complexity to the kernel.\n\n  Kernels may provide little to no abstraction at all. Kernels may be necessary for specific purposes instead of offering any resource to an upper layer. We can take the traffic light system as an example. The system may need to change states every 60 seconds, and that is all. For that, instead of having a Kernel, we could do some simple bare-metal programming, enable a timer interrupt and have a timer interrupt handler handle state changes1.\nThe computer organization and architecture Although there are different distinctions made between computer architecture and organization, the first refers to what systems and application programmers see, which are the attributes that have a direct impact on the execution of a program, for example, whether a computer will have a multiply instruction, where the latter refers to the operational unit and its interconnections that make the architectural specifications, such as whether the multiply instruction will be implemented by a multiply unit or by a mechanism of repeated add unit. The ISA, the numbers of bits used to represent data types, the IO structure, and approaches for memory addressing are all organizational issues that need to be structured (Stallings 2011).\nThe computer organization creates a hierarchy of hardware attributes details that are transparent to the programmer, such the interface between the computer and peripherals, the memory technology used, the type of processor and control signals (Stallings 2011). Computer architecture should offer a clean abstract set to simplify design, modeling, and allow running software to communicate with the hardware available (Patterson and Hennessy 2017).\nThe processor needs extra hardware in order to do its job, RAM to store program and data, support for logic and at least one I/O device to transfer data between the computer and the outside world (Catsoulis 2005)\nProcessors should be designed to process, store and retrieve data, but for that to happen, the processor has to go through several stages, where (i) fetch the instruction from memory, which could be the register, cache or main memory, (ii) decode the instruction to figure out what action is required to run, (iii) fetch data from memory or a IO module if required, (iv) perform arithmetic or logical operation on the fetched data if required and (v) the results of an execution may require to be written back to memory or the IO module (Stallings 2011).\nFinal conclusions We understood a modern computer is a complex set of hardware with different factors and use-cases. We saw how a kernel should interact with the hardware and how it should abstract the underlying hardware resources and provide some sort of API for programmers and users to interact. Not all problems are solvable with a kernel, some times pure bare-metal programming is what it takes to solve the problem, however, when we are willing to multitask, exchange communication between different resources, a Kernel might come in handy dealing with those problems.\nComputer organization is hierarchy of hardware attribute details that are transparent to the programmer, like IO functions, inter-process communication, memory management and etc.\nI hope with this post you were able to understand or remember key concepts of fundamental \u0026ldquo;modern\u0026rdquo; computing. Part 2 we will start implementing the initial boot of our kernel, starting by initializing the CPU and booting into QEMU\u0026rsquo;s RISC-V emulator and as we go along, I will introduce more concepts like those introduced in this post.\nReferences   Catsoulis, John. 2005. Designing Embedded Hardware. O\u0026rsquo;Reilly Media, Inc.\n  Patterson, D. A., and J. L. Hennessy. 2017. Computer Organization and Design Risc-V Edition: The Hardware Software Interface. The Morgan Kaufmann Series in Computer Architecture and Design. Elsevier Science. https://books.google.com.br/books?id=H7wxDQAAQBAJ.\n  Stallings, William. 2011. Operating Systems: Internals and Design Principles. 7th ed. Upper Saddle River, NJ, USA: Prentice Hall Press.\n    I don\u0026rsquo;t know how an actual traffic light system works, but I am assuming it\u0026rsquo;s some state-machine that handles interrupts of some kind. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':4,'href':'/menu/','title':"Menu",'content':" Blog Social  Github Twitter RSS    "});index.add({'id':5,'href':'/posts/hello-orgmode/','title':"Hello, org-mode and hugo",'content':"Hello, world! This is my first post here. This blog is created using Hugo and Emacs org-mode. I am still busy migrating my posts from Asciidoc to org-mode, so this should take a bit of time.\n"});index.add({'id':6,'href':'/notes/','title':"Notes",'content':"⚠️ Some notes I wrote and some of them are snippets I copied around the Internet. Unfortunately I don’t have the source for all of them, but I will try to keep this updated.\nNotes that tagged or start with TODO are notes that or I am still working on or that are simply incomplete 😔\n  I have discovered the reason for this code and it’s really quite necessary. Unfortunately this comment block is too short to contain it – Fermat\n Compilers Syntax Analysis Syntax analysis happens after the Lexical phase, and it is responsible for detecting syntax errors.\nGrammar Be design, computer languages have defined structure of what constitutes a valid program. in Python, a program is made up of functions/classes/imports, a function requires declarations and/or statements and so on. In C, a valid program needs to have a least a function called main, otherwise the GNU’s linker is unable to link the program.\nProgrammers may define language grammars using the Backus-Naur Form (BNF) notation. Defining grammars offer a lot of benefits for the language designer. Like code, language grammars may change overtime. For example, one of Python’s 3.5 new feature was the support to coroutines with async and await syntax.\nThe following diff shows some of the changes the developer needed to add support for the async before the function definition or allow an async function definition to be used as a decorator.\ndiff -r ccac513ee610 Grammar/Grammar --- a/Grammar/Grammar\tMon Apr 20 21:05:23 2015 +0200 +++ b/Grammar/Grammar\tMon Apr 20 15:54:06 2015 -0400 @@ -21,8 +21,11 @@  decorator: \u0026#39;@\u0026#39; dotted_name [ \u0026#39;(\u0026#39; [arglist] \u0026#39;)\u0026#39; ] NEWLINE decorators: decorator+ -decorated: decorators (classdef | funcdef) -funcdef: \u0026#39;def\u0026#39; NAME parameters [\u0026#39;-\u0026gt;\u0026#39; test] \u0026#39;:\u0026#39; suite +decorated: decorators (classdef | funcdef | async_funcdef) + +async_funcdef: ASYNC funcdef +funcdef: (\u0026#39;def\u0026#39; NAME parameters [\u0026#39;-\u0026gt;\u0026#39; test] \u0026#39;:\u0026#39; suite) +  parameters: \u0026#39;(\u0026#39; [typedargslist] \u0026#39;)\u0026#39; typedargslist: (tfpdef [\u0026#39;=\u0026#39; test] (\u0026#39;,\u0026#39; tfpdef [\u0026#39;=\u0026#39; test])* [\u0026#39;,\u0026#39; [\u0026#39;*\u0026#39; [tfpdef] (\u0026#39;,\u0026#39; tfpdef [\u0026#39;=\u0026#39; test])* [\u0026#39;,\u0026#39; \u0026#39;**\u0026#39; tfpdef] | \u0026#39;**\u0026#39; tfpdef]] @@ -37,18 +40,19 @@  simple_stmt: small_stmt (\u0026#39;;\u0026#39; small_stmt)* [\u0026#39;;\u0026#39;] NEWLINE small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt) Other than making it easier for the language designer to design the language, it allows the grammar to be easily documented and maintained by other language designers.\nSome grammars allow parsers (syntax analyzers) to be constructed to determine the syntactic structure of the program. By relying on the structured grammar, it allows the parsers to be developed more easily and testable.\nTypes of parsers There are 3 types of parsers we can use to write a syntax parser.\n Universal: this method can parse any grammar Top-down: this method builds parse trees from the top (root) to the button (leaves) Bottom-up: this method builds parse trees from the button (leaves) to the top (root)  The last two methods reads the input from left to right and one symbol at a time.\nThe top-down and bottom-up are known to be more efficient in production use1.\nTODO Math Integral Calculus  These are the two ways we commonly think about definite integrals: they describe an accumulation of a quantity, so the entire definite integral gives us the net change in that quantity.1\n Why Integral Calculus Figure 1 represents 2 graphs of y = cos(x). Let’s say we would like to calculate the area of   \\( x_1 \\)  . We could calculate the area by aproximation, for example, Graph B is filled with the area we would like to calculate, so we could divide this area by equal sections of \\(\\Delta x_n\\) from a to b rectangles, then we could calculate the area of these rectangles by \\(f(x_i) * \\Delta x_n\\) where \\(f\\) is the area of each of the rectangles. We do this for each rectangle then sum them up: \\(\\sum_{i=1}^n f(x_i) * \\Delta x_n\\). This will give us an approximation of our area, we could have a better approximation by having our \\(\\Delta x_n\\) smaller, but this implies that our n becomes bigger and bigger. The smaller \\(\\Delta x_n\\) gets, the more n approaches infinity.\nWe could use \\(\\liminf\\) of n as n approaches ∞ or \\(\\Delta x_n\\) as it gets very small.\nset multiplot layout 1, 2 title \u0026#34;f(x) = -x ** 2 + 4\u0026#34; set terminal pngcairo enhanced color size 350,262 font \u0026#34;Verdana,10\u0026#34; persist set linetype 1 lc rgb \u0026#39;#A3001E\u0026#39; set style fill transparent solid 0.35 noborder f(x) = -x ** 2 + 4 set title \u0026#34;A\u0026#34; plot f(x) with lines linestyle 1 set title \u0026#34;B\u0026#34; set style fill transparent solid 0.50 noborder plot f(x) fs solid 0.3 lc rgb \u0026#39;#A3001E\u0026#39; unset multiplot \n  The idea of getting better and better approximations is the what constitutes Integral Calculus.\nProgramming notes C programming C project architecture guidelines    Functions exposed in the header are like public methods\nThink of each module like a class. The functions you expose in the header are like public methods. Only put a function in the header if it part of the module’s needed interface.\n     Avoiding circular module dependencies\nAvoid circular module dependencies. Module A and module B should not call each other. You can refactor something into a module C to avoid that.\n     Operatins within the same module should have a create and delete function interface\nAgain, following the C++ pattern, if you have a module that can perform the same operations on different instances of data, have a create and delete function in your interface that will return a pointer to struct that is passed back to other functions. But for the sake of encapsulation, return a void pointer in the public interface and cast to your struct inside of the module.\n     Avoid module scope variables\nAvoid module-scope variables – the previously described pattern will usually do what you need. But if you really need module-scope variables, group them under a struct stored in a single module-scope variable called “m” or something consistent. Then in your code whenever you see “m.variable” you will know at a glance it is one of the module-scope structs.\n     Define HEADER name to avoid double including and/or header problems\nTo avoid header trouble, put #ifndef MY_HEADER_H #define MY_HEADER_H declaration that protects against double including. The header .h file for your module, should only contain #includes needed FOR THAT HEADER FILE. The module .c file can have more includes needed for the compiling the module, but don’t add those includes into the module header file. This will save you from a lot of namespace conflicts and order-of-include problems.\n  Go programming Packages In Go, programs start running in package main. Package names are defined by the last element of the import path: import math/rand has files which begin with the package rand. Packages consists of a bunch of .go files.\nPackage identifiers (functions, variables, struct and other data), may be used in other packages, with a few exceptions. Go allows only exported identifiers to be called after the package import. An exported identifier is any identifier which the first character starts in UPPER CASE. Any identifier which starts with a lower case letter is not exported.\nExported identifiers can be thought of public and private we see in other languages. This approach allows us to separate public API by using upper case character from private logic.\nPrivate identifier within a package may be referenced within its package.\nFunctions A function can have 0 or more arguments. All arguments must be typed: x int, y int, when 2 or consecutives arguments share the same type, arguments may be defined as so: x, y int.\nFunctions can return 0 or more number of results: return x, y. Function return values may be named, and must be defined after the function declaraction and before the beginning {\nfunc foobar(x, y int) (z int){ z = x * y return } The empty return will return the z value. Named return values should be used to document the meaning of the return values. Named return values should be used on short functions, as named values in large functions may become confusing.\nDefer Code snippets Python run HTTP server locally 1  python -m http.server 8000 --bind 127.0.0.1   Thesis OS Kit The OSKit is a framework and a set of 34 component libraries oriented to operating systems, together with extensive documentation. By providing in a modular way not only most of the infrastructure “grunge” needed by an OS, but also many higher-level components, the OSKit’s goal is to lower the barrier to entry to OS R\u0026amp;D and to lower its costs. The OSKit makes it vastly easier to create a new OS, port an existing OS to the x86 (or in the future, to other architectures supported by the OSkit), or enhance an OS to support a wider range of devices, file system formats, executable formats, or network services. The OSKit also works well for constructing OS-related programs, such as boot loaders or OS-level servers atop a microkernel\nMemory management Parkinson’s law Programs and their data expand to fill the memory available to hold them\nMemory hierarchy    Small fast and expensive memory up to a very slow and cheap memory\n  Processor registers    Processor cache    Random access memory (RAM)    Flash/USB memory    Hard drive    Tape backups       The part that handles memory in the operating system is called memory manager\n  The manager should be capable of allocating/deallocating memory for processes    Keep track of which location in memory is in use      Lowest cache level is generally handled by the hardware     Not having any memory abstraction at all is the simplest abstraction\nThe simplest memory abstraction is to have no abstraction at all, that being said, the programmer sees all the memory and may read/write from anywhere, however, this implies one program is running, otherwise one program may interfere with the other\n   One solution for allowing two or more programs running\nsimultaneously is if one program knows about the existence of the other. With this approach, the programmer requires to divide memory into 2 “blocks”, and allocate each block to the corresponding program, for example, the kernel may be at the button of memory and the program on top of it. It’s worth noting this implies the program may wipe (or read/write) the kernel address\n    Another solution is to store the kernel in ROM, and keep the program in RAM     When the kernel needs to switch process, it will load the the\nprogram from disk and overwrite the current running program\n     All the kernel needs to do is save the memory context to disk and\nload the new program\n     With the help of extra hardware, it is possible to divide memory\ninto blocks and protect other programs from accessing blocks of other programs loaded in memory\n   This brings a problem since programs may move data from physical\nmemory, say program A jumps to address `0x12` and program b copies data from in memory address `0x12`. When program A jumps to address `0x12` it would instead crash, since that was not the expected address. The problem is that both programs reference physical memory and this is **totally undesirable**, what is desirable is that programs reference a private set of local address to it\nSee: https://imgur.com/a/5FlWN4A\n     **Static relocation**: modify the second program on the fly as\nit loaded into memory (IBM 360 did this)\n         The operating system should coordinate on how these memories are handled\n   It should handle:\n  Keep track which parts of memory are in used and which aren’t    Allocate and deallocate memory    Swapping between main memory to disk when main memory is too small to hold the process         Memory abstractions\n   Address spaces\n  Allows multiple applications to be in memory at the same time    Prevents applications from interfering with each other    Abstract memory for programs to be stored in     Works like a telephone number\nin Brazil, it is common for local cities to have a 8-digit phone number, so the address space for the telephone number starts in 0000,0000 up to 9999,9999.\n       Stack pointer\n   RISC-V ABI’s stack pointer\nThe stack pointer points to the next available memory location on the stack, and the frame pointer points to the base of the stack frame.\n      Physical Memory management   Direct memory address to access a real location in RAM  Understanding RISC-V stack pointer L06 RISCV Functions(6up).pdf Code Linux trap handler void __init trap_init(void) { /* * Set sup0 scratch register to 0, indicating to exception vector * that we are presently executing in the kernel */ csr_write(CSR_SCRATCH, 0); /* Set the exception vector address */ csr_write(CSR_TVEC, \u0026amp;handle_exception); /* Enable all interrupts */ csr_write(CSR_IE, -1); } Send S-mode interrupts and most exceptions to S-mode // send S-mode interrupts and most exceptions straight to S-mode static void delegate_traps() { if (!supports_extension(\u0026#39;S\u0026#39;)) return; uintptr_t interrupts = MIP_SSIP | MIP_STIP | MIP_SEIP; uintptr_t exceptions = (1U \u0026lt;\u0026lt; CAUSE_MISALIGNED_FETCH) | (1U \u0026lt;\u0026lt; CAUSE_FETCH_PAGE_FAULT) | (1U \u0026lt;\u0026lt; CAUSE_BREAKPOINT) | (1U \u0026lt;\u0026lt; CAUSE_LOAD_PAGE_FAULT) | (1U \u0026lt;\u0026lt; CAUSE_STORE_PAGE_FAULT) | (1U \u0026lt;\u0026lt; CAUSE_USER_ECALL); write_csr(mideleg, interrupts); write_csr(medeleg, exceptions); assert(read_csr(mideleg) == interrupts); assert(read_csr(medeleg) == exceptions); } Timer interrupt in assembly   https://forums.sifive.com/t/beginner-trying-to-set-up-timer-irq-in-assembler-how-to-print-csrs-in-gdb/2764  Freedom metal Interrupt    Initialize CPU interrupt controller\nvoid __metal_driver_riscv_cpu_controller_interrupt_init( struct metal_interrupt *controller) { struct __metal_driver_riscv_cpu_intc *intc = (void *)(controller); uintptr_t val; if (!intc-\u0026gt;init_done) { /* Disable and clear all interrupt sources */ asm volatile(\u0026#34;csrc mie, %0\u0026#34; ::\u0026#34;r\u0026#34;(-1)); asm volatile(\u0026#34;csrc mip, %0\u0026#34; ::\u0026#34;r\u0026#34;(-1)); /* Read the misa CSR to determine if the delegation registers exist */ uintptr_t misa; asm volatile(\u0026#34;csrr %0, misa\u0026#34; : \u0026#34;=r\u0026#34;(misa)); /* The delegation CSRs exist if user mode interrupts (N extension) or * supervisor mode (S extension) are supported */ if ((misa \u0026amp; METAL_ISA_N_EXTENSIONS) || (misa \u0026amp; METAL_ISA_S_EXTENSIONS)) { /* Disable interrupt and exception delegation */ asm volatile(\u0026#34;csrc mideleg, %0\u0026#34; ::\u0026#34;r\u0026#34;(-1)); asm volatile(\u0026#34;csrc medeleg, %0\u0026#34; ::\u0026#34;r\u0026#34;(-1)); } /* The satp CSR exists if supervisor mode (S extension) is supported */ if (misa \u0026amp; METAL_ISA_S_EXTENSIONS) { /* Clear the entire CSR to make sure that satp.MODE = 0 */ asm volatile(\u0026#34;csrc satp, %0\u0026#34; ::\u0026#34;r\u0026#34;(-1)); } /* Default to use direct interrupt, setup sw cb table*/ for (int i = 0; i \u0026lt; METAL_MAX_MI; i++) { intc-\u0026gt;metal_int_table[i].handler = NULL; intc-\u0026gt;metal_int_table[i].sub_int = NULL; intc-\u0026gt;metal_int_table[i].exint_data = NULL; } for (int i = 0; i \u0026lt; METAL_MAX_ME; i++) { intc-\u0026gt;metal_exception_table[i] = __metal_default_exception_handler; } __metal_controller_interrupt_vector(METAL_DIRECT_MODE, \u0026amp;__metal_exception_handler); asm volatile(\u0026#34;csrr %0, misa\u0026#34; : \u0026#34;=r\u0026#34;(val)); if (val \u0026amp; (METAL_ISA_D_EXTENSIONS | METAL_ISA_F_EXTENSIONS | METAL_ISA_Q_EXTENSIONS)) { /* Floating point architecture, so turn on FP register saving*/ asm volatile(\u0026#34;csrr %0, mstatus\u0026#34; : \u0026#34;=r\u0026#34;(val)); asm volatile(\u0026#34;csrw mstatus, %0\u0026#34; ::\u0026#34;r\u0026#34;(val | METAL_MSTATUS_FS_INIT)); } intc-\u0026gt;init_done = 1; } }      Set trap vector configuration\nvoid __metal_controller_interrupt_vector(metal_vector_mode mode, void *vec_table) { uintptr_t trap_entry, val; asm volatile(\u0026#34;csrr %0, mtvec\u0026#34; : \u0026#34;=r\u0026#34;(val)); val \u0026amp;= ~(METAL_MTVEC_CLIC_VECTORED | METAL_MTVEC_CLIC_RESERVED); trap_entry = (uintptr_t)vec_table; switch (mode) { case METAL_SELECTIVE_VECTOR_MODE: asm volatile(\u0026#34;csrw mtvt, %0\u0026#34; ::\u0026#34;r\u0026#34;(trap_entry | METAL_MTVEC_CLIC)); asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; ::\u0026#34;r\u0026#34;(val | METAL_MTVEC_CLIC)); break; case METAL_HARDWARE_VECTOR_MODE: asm volatile(\u0026#34;csrw mtvt, %0\u0026#34; ::\u0026#34;r\u0026#34;(trap_entry | METAL_MTVEC_CLIC_VECTORED)); asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; ::\u0026#34;r\u0026#34;(val | METAL_MTVEC_CLIC_VECTORED)); break; case METAL_VECTOR_MODE: asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; ::\u0026#34;r\u0026#34;(trap_entry | METAL_MTVEC_VECTORED)); break; case METAL_DIRECT_MODE: asm volatile( \u0026#34;csrw mtvec, %0\u0026#34; ::\u0026#34;r\u0026#34;(trap_entry \u0026amp; ~METAL_MTVEC_CLIC_VECTORED)); break; } }   For DIRECT_ACCESS interrupt vector configuration IRC Switching from machine-mode to supervisor-mode! Privilege modes    Level Encoding Name Abbreviation     0 00 User/Application U   1 01 Supervisor S   2 10 Reserved    3 11 Machine M    Provides protection between different components of the software stack Any attempts to perform an operation not allowed by the current mode will cause an exception to be raised These exceptions will normally cause traps into the underlying execution environment Machine mode   Highest privilege    **Mandatory** privilege level for RISC-V hardware platform    Trusted code environment    Low level access to the machine implementation    Manage secure execution environments  User mode and supervisor mode are indented for conventional application and operating systems    Number of levels Supported modes Indented Usage     1 M Simple embedded systems   2 M, U Secure embedded systems   3 M, S U Unix-like operating systems    Exceptions   Any attempts to access non-existent CSR, read or write a read-only register raises an **illegal instruction**    A read/write register might also contain bits that are read-only, in which writes to read-only bits **are ignored**  Supervisor mode http://www-inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf\n**Steps to reproduce the behavior**   Switch to machine mode (if not already by default)  Books List Table 1: Clock summary at [2020-05-01 Fri 15:13]     Headline Time        Total time 3:49       List   3:49     Nonviolent Communication: A language…    3:49    READING Nonviolent Communication: A language for life  State “READING” from “TODO” [2020-04-29 Wed 17:50]  NEXT Clean Code **Mídia** - Noam Chomsky Duas concepções diferentes de democracia  Uma sociedade democrática é aquela em que o povo dispõe de  condições de participar de maneira significativa na condução de seus assuntos pessoais e na qual os canais de informação são acessíveis e livres\n O povo deve ser impedido de conduzir seus assuntos pessoais e os  canais de informação devem ser estreita e rigidamente controlados\n Essa é a concepção predominante Primeiras revoluções democráticas na Inglaterra do século XVII (17) expressam em grande medida esse ponto de vista  Primeira operação de propaganda governamental    Governo de Woodrow Wilson\n[[https://dynalist.io/u/ZQA1dAc7Eut0bwSRwZeMRqQ0]]\n     Presidente dos Estados Unidos em 1916\n   Plataforma “Paz sem Vitória”\n  Metade da Primeira Guerra Mundial      População bastante pacifista e sem motivo algum que justificasse envolvimento em guerra Europeia Constituída uma comissão de propaganda governamental    ComissãoCreel\nhttps://dynalist.io/u/7sEyNdz3VqlLWY9GpIypishZ\n  Committee on Public Information    1917 - 1919     Transformou uma população dentro de 6 meses\nConseguiua dentro de 6 meses transformar uma população pacifista em uma população histérica e belicosa que queria destruir tudo que fosse alemão\n  Efeito importante que levou a outros efeitos      Após a guerra, forma utilizadas as mesmas técnicas para gerar um Pânico Vermelho    Obteve êxito considerável na destruição de sindicatos e na eliminação de problemas perigosos como\n  Liberdade de imprensa    Liberdade de pensamento político       Grande apoio dos lideres empresariais e da mídia\n  Ambos organizaram e investiram muito na iniciativa    Intelectuais progressistas participaram ativamente    Pessoas do circulo de JohnDewey\nhttps://dynalist.io/u/4O4qv1%5Fwmp2T5nHYLMIiMcDD\n  Political thoughts Abortion should be legal, safe and rare   I am not really sure why this is, as I haven’t studied Universal methods] \u0026#x21a9;\u0026#xfe0e;\n   "});})();